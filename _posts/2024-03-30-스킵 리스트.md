---
layout: post
title: "[자료구조] 스킵 리스트(Skip List)"
date: 2024-03-29 15:00:00
categories: 자료구조
---

---

## Skip List란

스킵 리스트는 확률 밸런싱 기법을 이용하여 평균 시간 복잡도 `O(logN)`의 효율적인 삽입, 삭제, 검색 기능을 제공하는 인메모리 자료 구조이다. 컴퓨터 과학자인 William Pugh가 1990년대 처음 도입했으며, 균형 이진 탐색 트리보다 가벼운 대안으로 제안되었다.

스킵 리스트는 서로 다른 높이를 가진 여러 계층의 정렬된 연결 리스트를 사용하여 효율성을 달성한다. 각 계층은 통로 역할을 하며, 하위 계층의 특정 개수의 노드를 건너뛰도록 한다. 기존 연결 리스트에 비해 더 빠른 순회를 가능하게 하고 임의의 위치에 빠른 시간 복잡도로 삽입과 삭제를 수행할 수 있다.

스킵 리스트는 균형 이진 탐색 트리에 비해 비용이 큰 재조정 작업을 필요로 하지 않기 때문에 구현과 이해가 훨씬 쉽다. 또한 스킵 리스트는 최신 데이터베이스 관리 시스템(예: Apache Cassandra, CockroachDB)에서 널리 사용된다. 이러한 데이터베이스는 기본 저장 엔진의 핵심 구성 요소로 스킵 리스트를 활용하여 메모리 테이블(write 작업을 디스크에 SSTable 형태로 플러시하기 전에 일괄 처리하는 또 다른 메모리 상의 데이터 구조) 구현에 사용한다. 또한 Redis에서 Sorted Set의 구현에 사용된다.

---

## Skip List의 구조

Skip List는 여러 레이어의 연결 리스트로 구성된다. 각 레이어는 하나 이상의 노드를 갖는 연결 리스트로 구성된다. 이 구조는 데이터를 효율적으로 탐색, 삽입, 삭제하기 위해 고안되었다.

- 다중 레이어 구조: Skip List의 핵심은 여러 층으로 쌓인 연결 리스트이다. 가장 아래 레이어는 모든 데이터를 포함하고, 레벨이 올라갈 수록 더 적은 수의 데이터를 포함한다. 이는 각 노드가 여러 포인터를 가질 수 있도록 하여, 높은 레벨의 리스트에서 낮은 레벨로 효율적으로 건너뛸 수 있도록 한다.
- 포워드 포인터: 각 노드는 현재 노드에서 다음 노드로 연결하는 포인터(포워드 포인터)를 여러 개 가질 수 있다. 이 포인터들은 서로 다른 레벨을 가리키며, 탐색시 어떤 포인터를 따라갈 지를 결정함으로써 탐색 경로를 최적화한다.
- 확률적 레이어 구조: Skip List에서 노드가 속하는 레이어는 확률적으로 결정된다. 상위 레이어로 올라가는 확률은 약 0.5의 확률이다. (1 -> 0.5 -> 0.25 -> 0.125 -> ...) 일반적으로 노드가 높은 레벨에 위치할 확률은 매우 낮고, 대부분의 노드는 낮은 레벨에 위치한다. 이러한 설계는 리스트 전체의 균형을 자동으로 조정하며, 평균적으로 O(logN)의 탐색 시간 복잡도를 제공하는 데 기여한다.

```
   1                               10
 o---> o---------------------------------------------------------> o    Top level
   1           3              2                    5
 o---> o---------------> o---------> o---------------------------> o    Level 3
   1        2        1        2              3              2
 o---> o---------> o---> o---------> o---------------> o---------> o    Level 2
   1     1     1     1     1     1     1     1     1     1     1 
 o---> o---> o---> o---> o---> o---> o---> o---> o---> o---> o---> o    Bottom level
Head  1st   2nd   3rd   4th   5th   6th   7th   8th   9th   10th  NIL
      Node  Node  Node  Node  Node  Node  Node  Node  Node  Node
```

---

## Skip List의 내부 구현

Skip List의 기본 요소는 노드이다. 각 노드는 여러 포인터를 가질 수 있다. 각 포인터는 Skip List의 다른 레벨을 가리킨다. 가장 낮은 레벨은 데이터의 전체 목록을 담고 있으며, 레벨이 높아질수록 더 많은 데이터를 건너뛸 수 있게 된다. 이 구조 덕분에 데이터 탐색시 불필요한 노드 방문을 최소화할 수 있어, 평균적으로 효율적인 탐색 성능을 발휘한다.

---

## Skip List의 작동 원리

- 탐색: 원하는 값을 탐색하기 위해서는 가장 높은 레벨부터 시작하여 목표값보다 작거나 같은 값 중 최대값을 갖는 노드를 찾아간다. 이 때 탐색 경로가 목표값에 도달할 때까지 낮은 레벨로 내려가며 반복한다.
- 삽입: 새 노드를 삽입할 때에는 노드가 포함될 레벨을 무작위로 결정한다. 이를 확률적 결정이라고 한다. 결정된 레벨 이하의 모든 레벨에 새 노드를 삽입한다. 이 과정에서 삽입 위치를 결정하기 위해 탐색 연산이 사용된다.
- 삭제: 삭제할 노드를 탐색한 후, 해당 노드를 포함하는 모든 레벨에서 노드의 연결을 제거한다.

---

## Skip List의 장점

- 동적 크기 조절
    - Skip List는 노드의 삽입 및 삭제가 이루어질 때 자동으로 레벨을 조정하여, 전체 구조의 균형을 맞춘다. 이로 인해 균형 탐색 트리보다 구현이 간단하면서도 유사한 성능을 낼 수 있다.
- 효율적인 탐색 연산
    - Skip List는 평균적으로 O(logN)의 탐색 시간 복잡도를 갖는다. 최악의 경우에도 연결 리스트를 순차적으로 탐색하는 것보다 빠른 성능을 제공한다.

---

## Redis에서의 사용

Redis는 Skip List를 Sorted Set의 내부 구현에 사용한다. Sorted Set 명령어는 Skip List를 통해 구현된 데이터 구조 위에서 실행되므로, 키-값 쌍의 추가, 삭제, 조회 등의 연산이 효율적으로 수행된다.

---

## 결론

스킵 리스트는 연결 리스트와 비슷한 자료구조지만, 검색, 삽입, 삭제 작업을 더 빠르게 수행하도록 설계되었다. 여러 개의 연결 리스트를 여러 단계로 연결하여 구성되어 있으며, 각 단계는 이전 단계의 2배 길이를 갖는다. 스킵을 통해 데이터를 더 빠르게 건너뛰어 원하는 값을 찾을 수 있다.